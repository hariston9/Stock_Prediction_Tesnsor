# -*- coding: utf-8 -*-
"""Stock Prediction using Tensor Flow Keras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HoPlTdpdb9A4ToeKLr8iydrTUkHfqn5b
"""

#from IPython.core.debugger import Tracer; Tracer()()

!pip install ipython
import IPython

#import ipython
from IPython.core.debugger import set_trace
#%load_ext nb_black

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import time

plt.style.use(style="seaborn")
# %matplotlib inline

!pip install yfinance

import yfinance as yf
data = yf.download("MSFT", start="2013-01-01", end="2020-03-16")

import yfinance as yf
data = yf.download("MSFT", start="2013-01-01", end="2020-03-16")

import yfinance as yf
data2 = yf.download("BTC-USD", start="2020-03-01", end="2020-03-16")



data2

#df=pd.read_csv("data/MSFT-1Y-Hourly.csv")

df=pd.DataFrame(data)
df

df.info()

#df.set_index("date", drop=True, inplace=True )

df=df[["Close"]]

df

#type(df["close"]) == type(df[["close"]])

df.describe()

plt.figure(1, figsize=(16,6))
_=plt.plot(df.Close)

df["returns"]=df.Close.pct_change()

df.head(5)

1347.75/132.89-1

df["log_returns"]=np.log(1+df["returns"])

df.head(5)

plt.figure(1, figsize=(16,4))
plt.plot(df.log_returns)

df.dropna(inplace=True)
X=df[["Close", "log_returns"]].values

X

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0,1)).fit(X)
X_scaled = scaler.transform(X)

X_scaled[:5]

Y=[x[0] for x in X_scaled]

Y[:5]

split=int(len(X_scaled)*0.8)
print(split)

X_train=X_scaled[:split]
X_test=X_scaled[split:len(X_scaled)]
y_train=Y[:split]
y_test=Y[split:len(Y)]

assert len(X_train) ==len(y_train)
assert len(X_test) == len(y_test)

n=3
Xtrain=[]
ytrain=[]
Xtest=[]
ytest=[]

for i in range(n, len(X_train)):
    Xtrain.append(X_train[i-n:i, :X_train.shape[1]])
    ytrain.append(y_train[i])  # predict next record

for i in range(n, len(X_test)):
    Xtest.append(X_test[i-n:i, :X_test.shape[1]])
    ytest.append(y_test[i])  # predict next record

df.head(5)

Xtrain[0]

ytrain[0]

val=np.array(ytrain)

val=np.c_[val,np.zeros(val.shape)]

scaler.inverse_transform(val)

Xtrain, ytrain= (np.array(Xtrain), np.array(ytrain))
Xtrain=np.reshape(Xtrain, (Xtrain.shape[0], Xtrain.shape[1], Xtrain.shape[2]))

Xtest, ytest=(np.array(Xtest), np.array(ytest))

Xtest=np.reshape(Xtest, (Xtest.shape[0], Xtest.shape[1], Xtest.shape[2]))

print(Xtrain.shape)
print(ytrain.shape)
print("-----")
print(Xtest.shape)
print(ytest.shape)

#LSTM MODEL

from keras.models import Sequential
from keras.layers import LSTM, Dense

model=Sequential()
model.add(LSTM(4, input_shape=(Xtrain.shape[1], Xtrain.shape[2])))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer="adam")
model.fit(
    Xtrain, ytrain, epochs=100, validation_data=(Xtest, ytest), batch_size=16, verbose=1
)

model.summary()

trainPredict=model.predict(Xtrain)
testPredict=model.predict(Xtest)

trainPredict= np.c_[trainPredict, np.zeros(trainPredict.shape)]
testPredict= np.c_[testPredict, np.zeros(testPredict.shape)]

#Invert Predictions

trainPredict = scaler.inverse_transform(trainPredict)
trainPredict = [x[0] for x in trainPredict]

testPredict= scaler.inverse_transform(testPredict)
testPredict = [x[0]  for x in testPredict]

print(trainPredict[:5])
print(testPredict[:5])

print(df[:5])

from sklearn.metrics import mean_squared_error

# calculate root mean squared error

trainscore=mean_squared_error([x[0][0] for x in Xtrain], trainPredict, squared=False)
print("Train Score: %.2f RMSE" % (trainscore))

testscore=mean_squared_error([x[0][0] for x in Xtest], testPredict, squared=False)
print("Test Score: %.2f RMSE" % (testscore))

#pip install jupyterlab

#jupyter-lab